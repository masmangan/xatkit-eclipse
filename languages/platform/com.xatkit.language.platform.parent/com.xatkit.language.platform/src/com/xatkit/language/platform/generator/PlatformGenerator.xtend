/*
 * generated by Xtext 2.12.0
 */
package com.xatkit.language.platform.generator

import com.xatkit.intent.Context
import com.xatkit.intent.ContextParameter
import com.xatkit.intent.IntentFactory
import com.xatkit.platform.ActionDefinition
import com.xatkit.platform.EventProviderDefinition
import com.xatkit.platform.InputProviderDefinition
import com.xatkit.platform.Parameter
import com.xatkit.platform.PlatformDefinition
import com.xatkit.platform.PlatformFactory
import com.xatkit.utils.ImportRegistry
import java.util.Collections
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static java.util.Objects.nonNull

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PlatformGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val uri = resource.URI
		val PlatformDefinition platform = resource.contents.get(0) as PlatformDefinition
		var rr = resource.resourceSet.createResource(uri.trimFileExtension.appendFileExtension("xmi"))
		/*
		 * Clear the content of the resource, the output resource is created each time save is called, and may already 
		 * contain elements from a previous save.
		 */
		rr.contents.clear
		rr.contents.addAll(resource.contents)
		handlePlatformExtension(rr)
		rr.save(Collections.emptyMap())
		/*
		 * Update the imports associated to this platform (this allows to use the latest version of a platform under 
		 * development in an execution model)
		 */
		ImportRegistry.instance.updateImport(platform)
	}

	def void handlePlatformExtension(Resource resource) {
		var PlatformDefinition platform = resource.contents.get(0) as PlatformDefinition
		if(nonNull(platform.extends)) {
			for (ActionDefinition parentAction : platform.extends.actions) {
				platform.actions.add(deepCopy(parentAction))
			}
			for (EventProviderDefinition parentEventProvider : platform.extends.eventProviderDefinitions) {
				platform.eventProviderDefinitions.add(deepCopy(parentEventProvider))
			}
		}
	}

	private def EventProviderDefinition deepCopy(EventProviderDefinition from) {
		if(from instanceof InputProviderDefinition) {
			var InputProviderDefinition inputProviderDefinition = PlatformFactory.eINSTANCE.
				createInputProviderDefinition
			inputProviderDefinition.name = from.name
			for(Context outContext : from.outContexts) {
				inputProviderDefinition.outContexts.add(deepCopy(outContext))
			}
			// here, we don't copy the out contexts
			return inputProviderDefinition
		} else {
			throw new RuntimeException("Inheritance of EventProviders is not supported for now")
		}
	}

	private def ActionDefinition deepCopy(ActionDefinition from) {
		var ActionDefinition actionDefinition = PlatformFactory.eINSTANCE.createActionDefinition
		actionDefinition.name = from.name
		for (Parameter p : from.parameters) {
			actionDefinition.parameters.add(deepCopy(p))
		}
		return actionDefinition
	}
	
	private def Context deepCopy(Context from) {
		var Context context = IntentFactory.eINSTANCE.createContext
		context.name = from.name
		context.lifeSpan = from.lifeSpan
		for(ContextParameter contextParameter : from.parameters) {
			context.parameters.add(deepCopy(contextParameter))
		}
		return context
	}

	private def Parameter deepCopy(Parameter from) {
		var Parameter parameter = PlatformFactory.eINSTANCE.createParameter
		parameter.key = from.key
		return parameter
	}
	
	private def ContextParameter deepCopy(ContextParameter from) {
		var ContextParameter contextParameter = IntentFactory.eINSTANCE.createContextParameter
		contextParameter.name = from.name
		// TODO handle the other references
		return contextParameter
	}
}
